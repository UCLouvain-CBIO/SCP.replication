---
title: "SCP data analysis of the macrophage activation dataset (Woo et al. 2022)"
author:
    - Christophe Vanderaa, Computational Biology, UCLouvain
    - Laurent Gatto, Computational Biology, UCLouvain
output:
    BiocStyle::html_document:
        self_contained: yes
        toc: true
        toc_float: true
        toc_depth: 2
        code_folding: show
date: "`r BiocStyle::doc_date()`"
vignette: >
    %\VignetteIndexEntry{woo2022_macrophage data analysis}
    %\VignetteEngine{knitr::rmarkdown}
    %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
## Options for Rmarkdown compilation
knitr::opts_chunk$set(
    fig.width = 7,
    fig.height = 5,
    fig.align = "center",
    collapse = TRUE,
    crop = NULL ## Related to https://stat.ethz.ch/pipermail/bioc-devel/2020-April/016656.html
)
## Time the compilation
timeStart <- Sys.time()
```

# Introduction

In this vignette, we will analyse the `woo2022_macophage` dataset. The
data were acquired using the TIFF acquisition protocol
([Woo et al. 2022](http://dx.doi.org/10.1016/j.cels.2022.02.003)).
The authors performed a label-free experiment in DDA mode, and showed
that TIFF could improve the sensitivity and accuracy of label-free
single-cell proteomics (SCP).

# Packages and data

We rely on several packages to compile this vignette.

```{r load_packaes, warning=FALSE, message=FALSE}
## Core packages
library("scp")
library("scpdata")
## Utility packages
library("ggplot2")
library("patchwork")
library("dplyr")
library("scater")
```

The data set is available from the `scpdata` package. 

```{r scpdata}
woo <- woo2022_macrophage()
```

The data set contains 155 RAW264.7 cells: 54 are unstimulated cells, 
52 are LPS-stimulated cells at 24 h, and 49 LPS-stimulated cells at 
48 h.

```{r treatment}
table(woo$Treatment)
```

The data were acquired as part of 4 sample preparation chips that we
will consider as a potential source for batch effects. 

```{r batch}
table(woo$Chip)
```

# Minimal data processing

The minimal data processing workflow consist of 5 main steps:

- Data cleaning
- Feature quality control
- Sample quality control
- Log2-transformation

## Cleaning data

The data available in `scpdata` were provided authors and were 
analysed with MaxQuant. We here start with the non-normalised peptide
data. We recommend starting with data with least prior processing. We
therefore remove the maxLFQ normalised data and the protein data 
generated by MaxQuant.

```{r remove_assays, warning=FALSE}
names(woo)
assaysToRemove <- c(
    "peptides_LFQ", "proteins_intensity", "proteins_iBAQ", "proteins_LFQ"
)
woo <- removeAssay(woo, assaysToRemove)
```

Below is an overview of the `Qfeatures` object used as input data for
this data analysis. 

```{r}
woo
```

We remove feature annotations that won't be used in the remainder of
the vignette. This is to avoid overcrowding of the annotation tables
later in the vignette.

```{r}
requiredRowData <- c(
    "Sequence", "Proteins", "Leading.razor.protein", "Gene.names",
    "Protein.names", "Potential.contaminant", "Reverse", "PEP"
)
woo <- selectRowData(woo, requiredRowData)
```

We replace zeros by missing values. A zero may be a true (the feature
is not present in the sample) or because of technical limitations (due
to the technology or the computational pre-processing). Because we are
not able to distinguish between the two, zeros should be replaced with
`NA`.

```{r}
woo <- zeroIsNA(woo, i = names(woo))
```

## Feature quality control

We remove low-quality PSMs that may propagate technical artefacts and
bias data modelling. The quality control criteria are:

- We remove contaminants and decoy peptides.
- We remove low-confidence peptides with less than 1% FDR.

First, we need to convert PEP into q-value to control for FDR.

```{r compute_qvalue}
woo <- pep2qvalue(
    woo, i = names(woo), PEP = "PEP", rowDataName = "qvalue"
)
```

All the criteria to perform feature filtering are stored in the 
`rowData`. We remove any peptide matched to a contaminant protein or
to a decoy peptide and control for 1% FDR. Here is an overview of the
distributions of each criteria.

```{r echo=FALSE}
df <- data.frame(rbindRowData(woo, names(woo)))
df$ContaminantOrReverse <- df$Reverse == "+" |
    df$Potential.contaminant == "+" |
    grepl("REV|CON", df$Leading.razor.protein)
ggplot(df) + 
    aes(x = ContaminantOrReverse) +
    geom_bar() +
    ## q-value plot
    ggplot(df) + 
    aes(x = log10(qvalue)) +
    geom_histogram(bins = 50) +
    geom_vline(xintercept = -2) +
    xlim(-20, 0)
    
```

Peptide identification are already controlled for 1% FDR. We here 
remove contaminant and decoy peptides. 

```{r}
woo <- filterFeatures(
    woo, ~ Reverse != "+" & 
        Potential.contaminant != "+")
```


## Cell quality control


Similarly to the features, we also remove low-quality cells. The
quality control criteria are:

- We remove samples with low number of detected peptides. The 
criterion is computed as follows:

```{r}
woo <- countUniqueFeatures(
    woo, i = names(woo), colDataName = "NumberPeptides"
)
```

- We remove samples with low median intensity. The metric (note we 
will later use it for normalization) is computed as follows:

```{r}
woo$MedianIntensity <- colMedians(
    log10(assay(woo[["peptides_intensity"]])), na.rm = TRUE
)
```

- We remove the samples that have a high median coefficients of 
variation (CV). The CV is computed within each sample, by grouping
the peptides that belong to the same protein or protein group. This
is computed as follows:

```{r}
woo <- medianCVperCell(
    woo, i = "peptides_intensity", groupBy = "Leading.razor.protein",
    nobs = 5, norm = "SCoPE2", colDataName = "MedianCV"
)
```

We plot the metrics used to perform sample quality control.

```{r plot_cell_qc}
ggplot(data.frame(colData(woo))) +
    aes(
        y = MedianIntensity,
        x = NumberPeptides,
        color = MedianCV,
        shape = Treatment
    ) +
    geom_point(size = 2) +
    scale_color_continuous(type = "viridis")
```

There are a few suspicious cells with low number of detected peptides
and high median CV. We will remove cells with less than 400 peptides 
and with a median CV higher than 0.5. We will not use the median
intensity as a QC metric. We apply the filter and keep only single 
cells that pass the quality control.

```{r cell_qc}
passQC <- !is.na(woo$MedianCV) & woo$MedianCV < 0.5 &
    woo$NumberPeptides > 400
woo <- subsetByColData(woo, passQC)
```

## Log-transformation

We log2-transform the quantification data. 

```{r}
woo <- logTransform(woo, i = "peptides_intensity", name = "peptides_log")
```

# Data modelling

Model the data using the linear regression model implemented in `scp`.
The model is applied on a `SingleCellExperiment` so we extract it from
the processed data set along with the `colData`. 

```{r}
sce <- getWithColData(woo, "peptides_log")
```

First, we must specify which variables to include in the model. We 
here include 3 variables:

- `MedianIntensity`: this is the normalization factor used to correct 
  for cell-specific technical differences.
- `Chip`: the sample preparation chip is a potential source of batch
  effect.
- `Treatment`: this is the biological variable of interest.

`scpModelWorkflow()` fits linear regression models to the data, where the
model is adapted for each peptide depending on its pattern of missing
values. 

```{r data_modelling, results='hide'}
sce <- scpModelWorkflow(
    sce, 
    formula = ~ 1 + ## intercept
        ## normalization
        MedianIntensity +
        ## batch effects
        Chip + 
        ## biological variability
        Treatment
)
```

Once the model is prepared, we can explore the distribution of the n/p
ratios. 

```{r, message=FALSE}
scpModelFilterThreshold(sce) <- 2
scpModelFilterPlot(sce)
```

Many peptides do not have sufficient observations to estimate the 
model. We have chosen to continue the analysis with peptides that have
$n/p >= 2$. You could consider $n/p$ a rough average of the number of
replicates per parameter to fit (for categorical variables, the number
of replicates per group). We recommend moving the threshold away from
1 to increase statistical power and remove noisy peptides. This comes
of course at the cost of less peptides included in the analysis.

# Model analysis

The model analysis consists of three steps: 

- Variance analysis
- Differential abundance analysis
- Component analysis

## Variance analysis

The variance analysis explores the proportion of data captures by each
variable in the model. 

```{r variance_analysis}
(vaRes <- scpVarianceAnalysis(sce))
vaRes[[1]]
```

The results are a list of tables, one table for each variable. Each 
table reports for each peptide the variance captures (`SS`), the 
residual degrees of freedom for estimating the variance (`df`) and the
percentage of total variance explained (`percentExplainedVar`). To
better explore the results, we add the annotations available in the
`rowData`. 

```{r}
vaRes <- scpAnnotateResults(
    vaRes, rowData(sce), by = "feature", by2 = "Sequence"
)
```

By default, we explore the variance for all peptides combined:

```{r, fig.width=2.5, fig.height=4}
scpVariancePlot(vaRes)
```

We explore the top 20 peptides that are have the highest percentage of
variance explained by the biological variable (top) or by the batch
variable (bottom).

```{r, fig.width=10, fig.height=7}
scpVariancePlot(
    vaRes, top = 20, by = "percentExplainedVar", effect = "Treatment",
    decreasing = TRUE, combined = FALSE
) +
    scpVariancePlot(
    vaRes, top = 20, by = "percentExplainedVar", effect = "Chip",
    decreasing = TRUE, combined = FALSE
) +
    plot_layout(ncol = 1, guides = "collect")
```

We can also group these peptide according to their protein. We simply
need to provide the `fcol` argument.


```{r, fig.width=10, fig.height=7}
scpVariancePlot(
    vaRes, top = 20, by = "percentExplainedVar", effect = "Treatment",
    decreasing = TRUE, combined = FALSE, fcol = "Gene.names"
) +
    scpVariancePlot(
    vaRes, top = 20, by = "percentExplainedVar", effect = "Chip",
    decreasing = TRUE, combined = FALSE, fcol = "Gene.names"
) +
    plot_layout(ncol = 1, guides = "collect")
```

## Differential abundance analysis

Next, we explore the model output to understand the differences 
between treatment conditions. The difference of interest is
specified using the `contrast` argument. The first element points to 
the variable to test and the two following element are the groups of
interest to compare. Since we have 3 groups, we explore the three 
possible contrasts, provided as a list.

```{r}
(daRes <- scpDifferentialAnalysis(
    sce, contrast = list(c("Treatment", "CON", "LPS24"),
                         c("Treatment", "CON", "LPS48"),
                         c("Treatment", "LPS24", "LPS48"))
))
```

Similarly to variance analysis, the results are a list of tables, one 
table for each contrast. 

```{r}
daRes[[1]]
```

Each table reports for each peptide the 
estimated difference between the two groups, the standard error 
associated to the estimation, the degrees of freedom, the 
t-statistics, the associated p-value and the p-value FDR-adjusted for
multiple testing across all peptides. Again, to better explore the 
results, we add the annotations available in the `rowData`. 

```{r}
daRes <- scpAnnotateResults(
    daRes, rowData(sce), 
    by = "feature", by2 = "Sequence"
)
```

We then visualize the results using a volcano plot. The function below
return a volcano plot for each contrast. We here will show the results
for the first contrast.

```{r, warning=FALSE}
scpVolcanoPlot(daRes)[[1]]
```

To help interpretation of the results, we will label the peptides with
their protein name. Also we increase the number of labels shown on the plot.
Finally, we can add colors to the plot. For instance, let's explore 
the impact of the number of observations using the $n/p$ ratio. We
create a new annotation table, add it to the results and redraw the 
plot. The $n/p$ ratio is retrieved using scpModelFilterNPRatio. We 
show the improved plots for all contrasts.

```{r, fig.width=10, fig.height=4.5, warning=FALSE}
np <- scpModelFilterNPRatio(sce)
daRes <- scpAnnotateResults(
    daRes, data.frame(feature = names(np), npRatio = np), 
    by = "feature"
)
scpVolcanoPlot(
    daRes, top = 30, textBy = "Gene.names", 
    pointParams = list(aes(colour = npRatio))
) |> 
    wrap_plots(guides = "collect")
```

As expected, higher number of observations (higher $n/p$) lead to
increased statistical power and hence to more significant results.
We can already see that some proteins are upregulated upon treatment
such as heat shock proteins, Npm1 and Mdh2. 

Finally, we offer functionality to report results at the protein 
level. 

```{r, fig.width=10, fig.height=4.5, warning=FALSE}
scpDifferentialAggregate(daRes, fcol = "Gene.names") |> 
    scpVolcanoPlot(top = 30, textBy = "Gene.names") |> 
    wrap_plots()
```

## Component analysis

Finally, we perform component analysis to link the modelled effects to
the cellular heterogeneity. We here run an APCA+ (extended 
ANOVA-simultaneous principal component analysis) for the treatment 
effect. In other words, we perform a PCA on the data that is capture
by the treatment variable along with the residuals (unmodelled 
data).

```{r component_analysis, warning=FALSE}
(caRes <- scpComponentAnalysis(
    sce, ncomp = 20, method = "APCA", effect = "Treatment", 
    maxiter = 200
))
```

The results are contained in a list with 2 elements. `bySample`
contains the PC scores, that is the component results in sample space.
`byFeature` contains the eigenvectors, that is the component results
in feature space. 

```{r}
caRes$bySample
```

Each of the two elements contains components results
for the data before modelling (`unmodelled`), for the residuals or for
the APCA on the sample type variable (`APCA_Treatment`). 
Each elements is a table with the computed components. Let's explore
the component analysis results in cell space. Similarly to the
previous explorations, we annotate the results.

```{r}
caResCells <- caRes$bySample
sce$cell <- colnames(sce)
caResCells <- scpAnnotateResults(caResCells, colData(sce), by = "cell")
```

We then generate the component plot, colouring by `Treatment`. To 
assess the impact of batch effects, we shape the points according to 
the sample preparation batch (cf intro) as well.

```{r, fig.width=9, fig.height=3}
scpComponentPlot(
    caResCells,
    pointParams = list(aes(colour = Treatment, shape = Chip))
) |>
    wrap_plots() +
    plot_layout(guides = "collect")
```

The data before modelling already shows some data pattern driven by
the treatment as control samples are mostly characterized by low PC1
values, while treated cells show on average higher PC1 scores. However,
the data also shows batch effects as cells from the same batch tend to
group together. Batch effects are removed upon modelling and treatment
conditions are better separated although they still overlap. There is
not apparent structure in the residuals, indicating that the remaining
variation may be attributed to noise.

We explore further the variance that is hidden in later components. In
the chunk above, we computed 20 principal components. To explore the 
patterns they capture, we reduce these 20 PCs to 2 dimensions using 
t-SNE. We rely on the `scater` package to compute the t-SNE. 

```{r, fig.width=9, fig.height=3}
lapply(caResCells, function(ca) {
    pcs <- ca[, grep("^PC", colnames(ca))]
    tsne <- calculateTSNE(t(as.matrix(pcs)))
    data.frame(cbind(ca, tsne)) |> 
        ggplot() +
        aes(x = TSNE1,
            y = TSNE2,
            colour = Treatment,
            shape = Chip) +
        geom_point() +
        theme_minimal()
}) |> 
    wrap_plots(guides = "collect")
```

Taking the 20 principal components into account, we can see good 
separation between treatment after modelling while correctly mixing the
batch effects. We can also clearly see a clear clustering of the 
sample preparation batches when data is not modelled. Again, the 
residuals show no interesting clustering.

# Interactive visualisation with iSEE

You can manually explore the data through an interactive interface 
thanks to using the iSEE: 

```{r, eval=FALSE}
library("iSEE")
iSEE(sce)
```

# Session information {-}

```{r setup2, include = FALSE}
knitr::opts_chunk$set(
    collapse = TRUE,
    comment = "",
    crop = NULL
)
```

```{r sessioninfo, echo=FALSE}
sessionInfo()
```

# Citation

```{r citation}
citation("scp")
```

# License

This vignette is distributed under a 
[CC BY-SA license](https://creativecommons.org/licenses/by-sa/2.0/) 
license.
